# 委託簿重建與篩選機制設計文件

這份文件概述了如何根據 `選擇權序列價格篩選機制.docx` 與附錄 3 的規則，從原始行情 Tick 資料 (Raw Market Tick Data) 重建「委託簿快照」(即 `NearPROD`/`NextPROD` 檔案) 的邏輯。

## 1. 目標
在特定的快照時間點 (例如每 15 秒或 1 秒)，應用官方的篩選規則，準確重建每個選擇權序列的最佳買賣報價 (Best Bid/Ask)。

## 2. 資料來源

### A. 原始行情資料 (Raw Market Data)
**檔案格式**: CSV (例如 `J002-11300041_20251231_TXOA6.csv`)

根據實際檔案分析，欄位定義如下：
1.  **Date (`svel_i081_yymmdd`)**: 交易日期 (例如 `20251231`)。
2.  **Product ID (`svel_i081_prod_id`)**: 10 碼商品代號 (例如 `TXO22400A6`)。
    - **結構解析**: `PP` (2碼) + `T` (1碼) + `AAAAA` (5碼) + `CC` (2碼)
    - **PP (商品)**: 如 `TX`。
    - **T (類別)**: `O`=標準, `A-Z`=調整(非股票), `1-5`=週到期。
        - 範例: `TX` + `O` = `TXO` (台指選擇權)。
    - **AAAAA (履約價)**: 5碼整數 (例如 `22400` = 22400)。
    - **CC (到期年月)**:
        - **C1 (月份碼)**: A-L (Call Jan-Dec), M-X (Put Jan-Dec)。
        - **C2 (年份碼)**: 尾數對應。
            - **規則**: `6` 對應 `2026`。 (基於 2025/12/31 資料，預設 `6` 為次年)。
 3.  **Time (`svel_i081_time`)**: 交易所時間戳記，格式 `HHMMSSuuuuuu` (例如 `084500083000` = 08:45:00.083000)。
 4.  **Bid Price (`svel_i081_best_buy_price1`)**: 最佳一檔買進價格 (4位小數)。
 5.  **Ask Price (`svel_i081_best_sell_price1`)**: 最佳一檔賣出價格 (4位小數)。
### B. 觸發/排程檔 (Trigger/Schedule)
**路徑**: `c:\Users\jerry1016\.gemini\antigravity\VIX\資料來源\20251231\`
- **近月來源**: `NearPROD_20251231.tsv`
- **次近月來源**: `NextPROD_20251231.tsv`

**讀取邏輯 (Header Handling)**:
根據檔案分析，前三行結構特殊：
1.  **Line 1**: 欄位名稱 (Header)。
2.  **Line 2 (Special Start Row)**: 包含起始時間 `84500` (Column A) 與 起始 SysID `22934` (Column B)。需作為當日的第一個快照點處理。
3.  **Line 3+**: 標準資料列，對應 Header 欄位。

**排程提取**:
- 程式需提取 Line 2 的 `(Time=84500, SysID=Col[1])`。
- 接續提取 Line 3+ 的 `time` 與 `snapshot_sysID` 欄位 (去除重複 Time)。

### C. 原始行情資料 (Raw Market Data)
**路徑**: `c:\Users\jerry1016\.gemini\antigravity\VIX\資料來源\J002-11300041_20251231\`
- **檔案**: 預計包含 4 個 .csv 檔案。
- **處理邏輯**: 程式需讀取該資料夾下所有 CSV，並合併處理。

### D. 自動區分近月與次近月 (Dynamic Term Logic)
程式需依照 `Product ID` 解析結果自動分類 Ticks，**不可將月份寫死**：

1.  **日期檢查 (Date Validation)**:
    - 讀取 Raw Ticks 時，比對 `svel_i081_yymmdd` 是否等於 `Target Date` (例如 20251231)。
    - 若日期不符，該筆剔除。

2.  **動態判斷 Near/Next**:
    - 掃描當日所有資料，收集所有出現的 **到期月份** (`YYYYMM`)。
    - 將月份 **由小到大排序**。
    - **Near Term**: 排序後的第 1 個月份 (Index 0)。
    - **Next Term**: 排序後的第 2 個月份 (Index 1)。
    - *範例*: 若收集到 `[202601, 202602, 202603]`, 則 `202601`=Near, `202602`=Next。

3.  **重建目標**:
    - `NearPROD` 重建時，只使用屬於 **Near Term** 的 Ticks。
    - `NextPROD` 重建時，只使用屬於 **Next Term** 的 Ticks。

## 3. 篩選邏輯 (機制核心)

根據官方文件及其附錄 3，雖然有提到兩種方法，但 VIX 計算應採用 **方法 2**。

### 方法 1：最後一筆報價 (Last Quote) - 僅供參考
這是最直觀的方法，尋找快照觸發前最新的一筆有效報價。
- **輸入**: 目標 `Snapshot_SysID`。
- **演算法**:
    1.  篩選出特定 **序列** 的所有 Ticks。
    2.  找到 `Tick_SysID <= Snapshot_SysID` 的資料。
    3.  選取其中 `Tick_SysID` 最大 (最新) 的一筆。
- **備註**: 根據附錄 3 分析，這**不是** VIX 主要採用的方法。

### 方法 2：區間內最小價差 (Latest & Min Spread) - [官方 VIX 採納]
**基於 `4.13_附件4...docx` 附錄 3 (表 8-11)**：
此方法優先考慮「報價品質」(價差越小越好)，而非單純的「最新」。

- **搜尋視窗**: 回溯目標時間點 `t` 前的 **15 秒**。
- **演算法邏輯**:
    1.  收集區間 `[t-15s, t]` 內該序列的所有報價。
    2.  **第一層篩選 (最小價差)**: 找出這些報價中，買賣價差 (Spread = Ask - Bid) **最小** 的集合。
    3.  **第二層篩選 (最新)**: 如果有多筆報價的價差同樣最小，則從中選取時間最晚 (SysID 最大) 的那一筆。
- **證據**: 文件表 8 顯示，即便在 `09:04:42` 有最新報價（但價差高達 76），系統依然選擇了 `09:04:36` 的舊報價（因為價差只有 1.0）。這證實了演算法會為了較佳的流動性而選用稍舊的資料。

## 4. 實作流程

### 步驟 1：資料載入與索引 (Ingest & Index)
- 載入原始 Ticks 並建立適合時間序列查詢的結構 (例如 Pandas DataFrame，依 `SysID` 或 `Time` 排序)。
- 建立索引：`[Strike, SysID]`。

### 步驟 2：快照生成迴圈 (Snapshot Generation)
針對排程檔中的每一個 `Target_Time` 與 `Snapshot_SysID`：
1.  **鎖定活躍序列**: 遍歷所有相關的選擇權序列。
2.  **應用篩選器**:
    - 使用 **方法 2** (15秒回溯 + 最小價差) 查詢 Tick 索引。
3.  **輸出結果**:
    - 產生一列資料：`Time`, `Strike`, `Filtered_Bid`, `Filtered_Ask`, `Tick_SysID` (用於驗證)。

## 5. 待確認事項
1.  **原始資料狀況**: 您手邊是否有 `Raw Market Ticks` (原始逐筆行情)？如果要執行此重建工作，這是必須的。如果只有 `NearPROD`，那我們只能直接進行 VIX 計算，無法執行此重建步驟。
